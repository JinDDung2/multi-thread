# Java 멀티스레딩, 병행성 및 병렬 실행 프로그래밍 배우기

## 멀티쓰레드가 필요한 이유
1. Responsiveness
- 병행성 : 멀티쓰레드로 빠른 멀티태스킹을 구현하면 동시에 실행하는 듯한 착각(illusion)을 줌
- 병행성을 구현하기 위해 반드시 멀티 코어일 필요는 없음
2. Performance
- 멀티쓰레드가 성능에 미치는 영향은 짧은 시간 안에 복잡한 작업을 완료하는 것인데, 당연히 싱글 스레드 보 더 많은 작업을 수행할 수 있음

## 멀티쓰레드를 사용할 때 주의사항
- 멀티쓰레드 프로그래밍은 기존 단일쓰레드의 순차적인 프로그래밍과는 다름. 멀티쓰레드를 사용하는 순간 바로 OO가 깨짐.

## 쓰레드와 컨텍스트 스위칭에 대한 이해
- 많은 쓰레드는 많은 컨텍스트 스위칭을 야기함
- 쓰레드가 프로세스보다 컨텍스트 스위칭 비용이 적음 (쓰레드는 일부 자원을 공유하기 때문)
- 같은 프로세스에 속한 쓰레드 끼리 컨텍스트스위칭 하는 비용 < 각각 다른 프로세스의 쓰레드 컨텍스트 스위칭 비용

## 쓰레드 생성 방법
- 쓰레드 클래스 객체를 인스턴스화 하여 Runnable을 생성자에 전달
```java
Thread thread = new Thread(new Runnable() -> ~~)
```
- Thread를 상속하는 클래스를 만듬
```java
class NewThread extends Thread {
        @Override
        public void run() {
            System.out.println("쓰레드 이름: " + this.getName());
        }
    }
```

## 데몬 쓰레드
1. 백그라운드에서 실행 -> 메인 쓰레드가 종료되더라도 애플리케이션은 종료 안됨
2. 앱의 주 기능 보다는 백그라운드 작업을 실행
3. 텍스트 편집기를 쓸 때 일정 시간마다 자동 저장되는 경우가 이러한 경우임
4. 데몬 쓰레드는 애플리케이션 종료와 독립적이어야 함

## 쓰레드 간의 협력
- 스핀락 -> CPU 낭비 -> 효율성 저하 (적절하지 않는 방법)
- wait 방식 활용 -> Thread.join()

### 주의할 점
- 다른 쓰레드의 실행 순서에 의존하지 않음
- 믿을만한 결과를 도출하려면 쓰레드 coordination 필요
- 한 쓰레드가 완료하는데 지나치게 오래걸리는 상황을 항상 고려해야함
- 위와 같은 상황을 해결하기 위해 join을 통해 기다리는 시간을 정해 두어야 함
- 제시간에 작업을 맞추지 못한 쓰레드는 멈춰야 한다.