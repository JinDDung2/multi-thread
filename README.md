# Java 멀티스레딩, 병행성 및 병렬 실행 프로그래밍 배우기

## 멀티쓰레드가 필요한 이유
1. Responsiveness
- 병행성 : 멀티쓰레드로 빠른 멀티태스킹을 구현하면 동시에 실행하는 듯한 착각(illusion)을 줌
- 병행성을 구현하기 위해 반드시 멀티 코어일 필요는 없음
2. Performance
- 멀티쓰레드가 성능에 미치는 영향은 짧은 시간 안에 복잡한 작업을 완료하는 것인데, 당연히 싱글 스레드 보 더 많은 작업을 수행할 수 있음

## 멀티쓰레드를 사용할 때 주의사항
- 멀티쓰레드 프로그래밍은 기존 단일쓰레드의 순차적인 프로그래밍과는 다름. 멀티쓰레드를 사용하는 순간 바로 OO가 깨짐.

## 쓰레드와 컨텍스트 스위칭에 대한 이해
- 많은 쓰레드는 많은 컨텍스트 스위칭을 야기함
- 쓰레드가 프로세스보다 컨텍스트 스위칭 비용이 적음 (쓰레드는 일부 자원을 공유하기 때문)
- 같은 프로세스에 속한 쓰레드 끼리 컨텍스트스위칭 하는 비용 < 각각 다른 프로세스의 쓰레드 컨텍스트 스위칭 비용

## 쓰레드 생성 방법
- 쓰레드 클래스 객체를 인스턴스화 하여 Runnable을 생성자에 전달
```java
Thread thread = new Thread(new Runnable() -> ~~)
```
- Thread를 상속하는 클래스를 만듬
```java
class NewThread extends Thread {
        @Override
        public void run() {
            System.out.println("쓰레드 이름: " + this.getName());
        }
    }
```

## 데몬 쓰레드
1. 백그라운드에서 실행 -> 메인 쓰레드가 종료되더라도 애플리케이션은 종료 안됨
2. 앱의 주 기능 보다는 백그라운드 작업을 실행
3. 텍스트 편집기를 쓸 때 일정 시간마다 자동 저장되는 경우가 이러한 경우임
4. 데몬 쓰레드는 애플리케이션 종료와 독립적이어야 함

## 쓰레드 간의 협력
- 스핀락 -> CPU 낭비 -> 효율성 저하 (적절하지 않는 방법)
- wait 방식 활용 -> Thread.join()

### 주의할 점
- 다른 쓰레드의 실행 순서에 의존하지 않음
- 믿을만한 결과를 도출하려면 쓰레드 coordination 필요
- 한 쓰레드가 완료하는데 지나치게 오래걸리는 상황을 항상 고려해야함
- 위와 같은 상황을 해결하기 위해 join을 통해 기다리는 시간을 정해 두어야 함
- 제시간에 작업을 맞추지 못한 쓰레드는 멈춰야 한다.

## 멀티쓰레드의 Performance 측정 척도
- 지연시간 : 시간 단위의 측정이며, 하나의 작업이 완료되는 시간
- 처리량 : 일정 시간 동안의 처리한 작업의 양

## 멀티쓰레드 애플리케이션의 Performance
- 지연시간 : 시간 단위의 측정이며, 하나의 작업이 완료되는 시간
- 처리량 : 일정 시간 동안의 처리한 작업의 양
- 쓰레드 풀링 사용 -> 쓰레드 생성 및 관리에 드는 불필요한 시간 제거, 작업을 하위 작업으로 쪼개는 작업이 불필요
- 자바에서는 낮은 오버헤드와 효율적은 대기열을 구현

## 쓰레드 간의 리소스 공유
- 리소스 : 컴퓨터 프로그램 영역에서의 리소스는 데이터나 어떤 상태를 의미
- 쓰레드가 공유 가능한 리소스 -> 힙 메모리 / 쓰레드가 공유 불가능한 것 -> 스택 메모리(스택메모리 일부를 공유할 수는 있긴 함)

## 자바가 제공하는 synchornized
- 여러개의 쓰레드가 코드 블록이나 전체 메서드에 액세스 할 수 없도록 설계된 락킹 매커니즘
- 전체 메서드를 동기화할 필요는 없음 -> 실행하는데  필요한 최소한만 임계영역으로 설정 -> 더 많은 코드를 여러 쓰레드가 접근 가능 -> 성능 향상 가능

